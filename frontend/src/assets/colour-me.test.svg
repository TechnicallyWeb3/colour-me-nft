<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="1000" height="1000" viewBox="0 0 1000 1000"><defs><style>.toolbar {fill: #f0f0f0; stroke: #ccc; stroke-width: 1;}.canvas {fill: white; stroke: #ccc; stroke-width: 1;}#drawing-area {pointer-events: none;}text {font-family: Arial, sans-serif; font-size: 14px; fill: #333;}.toolbar-text {font-size: 12px;user-select: none;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;}.button-text {font-size: 20px;fill: white;pointer-events: none;user-select: none;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;}.color-btn, .brush-size, .tool-bg, .action-bg {cursor: pointer;}.color-btn {stroke: #333; stroke-width: 2;}.color-btn:hover {stroke: #777; stroke-width: 3;}.color-btn.active {stroke: #000; stroke-width: 3;}#brush-slider-handle {cursor: grab;}#brush-slider-handle:active {cursor: grabbing;}#brush-slider-track {cursor: pointer;}.tool-button {font-size: 20px;fill: #666;transition: fill 0.2s;user-select: none;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;}.tool-button:hover {fill: #333;}.tool-button.active {fill: #333;}.tool-bg {fill: #f0f0f0; stroke: #ccc; stroke-width: 1; rx: 5; ry: 5;}.tool-bg:hover {fill: #e0e0e0; stroke: #999;}.tool-bg.active {fill: #333; stroke: #333;}.tool-bg.active:hover {fill: #444; stroke: #444;}.tool-group {cursor: pointer;}.tool-group:hover .tool-bg {fill: #e0e0e0; stroke: #999;}.tool-group:hover .tool-bg.active {fill: #444; stroke: #444;}.shape-group {cursor: pointer;}.shape-group:hover .tool-bg {fill: #e0e0e0; stroke: #999;}.shape-group:hover .tool-bg.active {fill: #444; stroke: #444;}.shape-group .tool-bg.active ~ .shape-icon {stroke: white !important;}.shape-btn { cursor: pointer; }.action-bg {fill: #f0f0f0; stroke: #ccc; stroke-width: 1; rx: 5; ry: 5;}.action-bg:hover {fill: #e0e0e0; stroke: #999;}.action-bg.undo {fill: #fff3e0; stroke: #ffcc02;}.action-bg.undo:hover {fill: #ffcc02; stroke: #ffa000;}.action-bg.redo {fill: #f3e5f5; stroke: #ce93d8;}.action-bg.redo:hover {fill: #ce93d8; stroke: #ba68c8;}.action-bg.clear {fill: #ffebee; stroke: #ffcdd2;}.action-bg.clear:hover {fill: #ffcdd2; stroke: #ef9a9a;}.action-bg.save {fill: #e8f5e8; stroke: #c8e6c9;}.action-bg.save:hover {fill: #c8e6c9; stroke: #a5d6a7;}.action-bg.export {fill: #e3f2fd; stroke: #bbdefb;}.action-bg.export:hover {fill: #bbdefb; stroke: #90caf9;}.action-bg.inactive {fill: #f5f5f5 !important; stroke: #e0e0e0 !important; pointer-events: none;}.action-bg.inactive:hover {fill: #f5f5f5 !important; stroke: #e0e0e0 !important; pointer-events: none;}.button-text.inactive {fill: #bdbdbd !important;}</style><rect id="canvas-bg" x="10" y="90" width="980" height="900" rx="5"/><clipPath id="canvas-clip"><use href="#canvas-bg"/></clipPath></defs><rect width="1000" height="1000" fill="#e8e8e8"/><use href="#canvas-bg" class="canvas"/><rect x="10" y="10" width="980" height="70" class="toolbar" rx="5"/><g id="brush-size-controls"><rect x="300" y="25" width="120" height="20" fill="#f0f0f0" stroke="#ccc" stroke-width="1" rx="10"/><rect id="brush-slider-track" x="305" y="27.5" width="110" height="15" fill="#ddd" rx="7.5"/><circle id="brush-slider-handle" cx="310" cy="35" r="8" fill="#4CAF50" stroke="#45a049" stroke-width="2" cursor="pointer"/></g><circle cx="50" cy="35" r="15" class="color-btn active" fill="#000000"/><circle cx="90" cy="35" r="15" class="color-btn" fill="#359bd5"/><circle cx="130" cy="35" r="15" class="color-btn" fill="#37f4b0"/><circle cx="170" cy="35" r="15" class="color-btn" fill="#c101fa"/><circle cx="210" cy="35" r="15" class="color-btn" fill="#47cc49"/><circle cx="250" cy="35" r="15" class="color-btn" fill="#4aaca3"/><g class="shape-group" transform="translate(445, 20)"><rect x="0" y="0" width="30" height="30" class="tool-bg" data-shape="line"/><line x1="5" y1="10" x2="25" y2="20" fill="none" stroke="#333" stroke-width="2" class="shape-icon"/></g><g class="shape-group" transform="translate(485, 20)"><rect x="0" y="0" width="30" height="30" class="tool-bg" data-shape="rect"/><rect x="5" y="7.5" width="20" height="15" fill="none" stroke="#333" stroke-width="2" class="shape-icon"/></g><g class="shape-group" transform="translate(525, 20)"><rect x="0" y="0" width="30" height="30" class="tool-bg" data-shape="polygon-5"/><polygon points="15,5 25,12 20,22.5 10,22.5 5,12" fill="none" stroke="#333" stroke-width="2" class="shape-icon"/></g><g id="drawing-area" clip-path="url(#canvas-clip)" data-token="1"><polygon fill="#000000" points="891,649 823,741 715,706 715,591 823,556 "/><line fill="none" stroke="#37f4b0" stroke-width="6" x1="879" y1="423" x2="419" y2="340"/><rect fill="#47cc49" x="388" y="652" width="413" height="267"/><path stroke-linecap="round" stroke-linejoin="round" fill="none" stroke="#359bd5" stroke-width="2" d="M-128 470 L297 29 L483 327 L1130 225 L1029 586 L730 202 L-166 -173 L1085 -200 L624 713 L860 518 L-296 1 L559 885 L1243 416 L596 -40"/><rect fill="#359bd5" x="100" y="133" width="308" height="241"/><line fill="none" stroke="#37f4b0" stroke-width="7" x1="802" y1="590" x2="396" y2="181"/><polygon fill="#37f4b0" points="1153,778 1067,895 928,850 928,705 1067,660 "/><rect fill="#4aaca3" x="-136" y="-13" width="243" height="350"/><path stroke-linecap="round" stroke-linejoin="round" fill="none" stroke="#359bd5" stroke-width="3" d="M835 762 L385 294 L446 292 L-231 662 L1087 397 L913 489 L657 408 L839 218 L623 411 L725 -10 L1094 385 L-271 998"/><rect fill="#37f4b0" x="390" y="615" width="90" height="415"/><path stroke-linecap="round" stroke-linejoin="round" fill="none" stroke="#359bd5" stroke-width="2" d="M-240 628 L-76 279 L971 682 L1234 99 L1003 771 L178 503 L-109 177 L-190 -158 L-81 511 L46 261"/><path stroke-linecap="round" stroke-linejoin="round" fill="none" stroke="#c101fa" stroke-width="4" d="M1014 964 L-130 442 L958 36 L-116 586 L-256 698 L980 541 L-293 645 L474 748 L774 113 L-213 91 L1019 24 L416 11 L964 6 L577 406 L353 -123 L1050 -10 L682 3 L303 651"/><line fill="none" stroke="#359bd5" stroke-width="8" x1="-108" y1="431" x2="299" y2="257"/><rect fill="#000000" x="1104" y="336" width="114" height="227"/><line fill="none" stroke="#37f4b0" stroke-width="3" x1="-135" y1="994" x2="240" y2="228"/></g><g class="tool-group"><rect x="575" y="20" width="30" height="30" class="tool-bg active"/><text x="590" y="40" text-anchor="middle" class="tool-button">üñåÔ∏è</text></g><g class="tool-group"><rect x="615" y="20" width="30" height="30" class="tool-bg"/><text x="630" y="40" text-anchor="middle" class="tool-button">üßΩ</text></g><g class="tool-group"><rect x="655" y="20" width="30" height="30" class="tool-bg"/><text x="670" y="40" text-anchor="middle" class="tool-button">ü™£</text></g><g class="action-group"><rect x="720" y="20" width="40" height="30" class="action-bg undo inactive"/><text x="740" y="40" text-anchor="middle" class="button-text inactive">‚Ü∂</text><text x="740" y="65" text-anchor="middle" class="toolbar-text">Undo</text></g><g class="action-group"><rect x="770" y="20" width="40" height="30" class="action-bg redo inactive"/><text x="790" y="40" text-anchor="middle" class="button-text inactive">‚Ü∑</text><text x="790" y="65" text-anchor="middle" class="toolbar-text">Redo</text></g><g class="action-group"><rect x="820" y="20" width="40" height="30" class="action-bg clear"/><text x="840" y="40" text-anchor="middle" class="button-text">üí£</text><text x="840" y="65" text-anchor="middle" class="toolbar-text">Clear</text></g><g class="action-group"><rect x="870" y="20" width="40" height="30" class="action-bg save"/><text x="890" y="40" text-anchor="middle" class="button-text">üíæ</text><text x="890" y="65" text-anchor="middle" class="toolbar-text">Save</text></g><g class="action-group"><rect x="920" y="20" width="40" height="30" class="action-bg export"/><text x="940" y="40" text-anchor="middle" class="button-text">üìÅ</text><text x="940" y="65" text-anchor="middle" class="toolbar-text">Export</text></g><text x="150" y="65" text-anchor="middle" class="toolbar-text">Colors</text><text x="350" y="65" text-anchor="middle" class="toolbar-text">Brush Size</text><text x="500" y="65" text-anchor="middle" class="toolbar-text">Shapes</text><text x="630" y="65" text-anchor="middle" class="toolbar-text">Tools</text><script type="text/javascript"><![CDATA[const SVG_NS = 'http://www.w3.org/2000/svg';const XHTML_NS = 'http://www.w3.org/1999/xhtml';const drawingArea = document.getElementById('drawing-area');const canvas = document.querySelector('.canvas');const svg = document.querySelector('svg');const brushSlider = document.getElementById('brush-slider-handle');const brushSliderTrack = document.getElementById('brush-slider-track');const localStorageKey = 'colourMeArt.' + (drawingArea.getAttribute('data-token') || '0');let isDrawing = false;let isDraggingSlider = false;let currentColor = '#000000';let currentBrushSize = 8;let currentTool = 'brush';let currentShape = 'rect';let paths = [];let currentPath = null;let startPos = null;let currentShapeElement = null;let polylinePoints = [];let polylinePreview = null;let mouseMoveThrottle = null;let lastDrawPos = null;let svgRect = null;let svgWidth = 1000;let svgHeight = 1000;let displayWidth = 1000;let displayHeight = 1000;let redoStack = [];const MAX_REDO_STACK = 100;function updateCoordinateFactors() {svgRect = svg.getBoundingClientRect();svgWidth = svg.viewBox.baseVal.width;svgHeight = svg.viewBox.baseVal.height;displayWidth = svgRect.width;displayHeight = svgRect.height;}function calculatePosition(clientX, clientY) {if (!svgRect) updateCoordinateFactors();const x = clientX - svgRect.left;const y = clientY - svgRect.top;const rawX = (x * svgWidth) / displayWidth;const rawY = (y * svgHeight) / displayHeight;return {x: Math.round(rawX),y: Math.round(rawY)};}function getMousePos(evt) {return calculatePosition(evt.clientX, evt.clientY);}function getTouchPos(evt) {const touch = evt.touches[0];return calculatePosition(touch.clientX, touch.clientY);}function createSVGElement(tagName, attributes = {}) {const element = document.createElementNS(SVG_NS, tagName);Object.entries(attributes).forEach(([key, value]) => {element.setAttribute(key, value);});return element;}function setActiveElement(selector, activeElement) {document.querySelectorAll(selector).forEach(el => el.classList.remove('active'));if (activeElement) activeElement.classList.add('active');}const shapeConfigs = {rect: (pos) => ({fill: currentColor, x: pos.x, y: pos.y, width: 1, height: 1}),ellipse: (pos) => ({fill: currentColor, cx: pos.x, cy: pos.y, rx: 1, ry: 1}),line: (pos) => ({stroke: currentColor, 'stroke-width': currentBrushSize,x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y}),'polygon-3': (pos) => ({fill: currentColor,points: `${pos.x},${pos.y} ${pos.x + 1},${pos.y + 1} ${pos.x - 1},${pos.y + 1}`}),'polygon-5': (pos) => ({fill: currentColor,points: `${pos.x},${pos.y - 0.5} ${pos.x + 0.5},${pos.y - 0.3} ${pos.x + 0.3},${pos.y + 0.5} ${pos.x - 0.3},${pos.y + 0.5} ${pos.x - 0.5},${pos.y - 0.3}`}),'polygon-6': (pos) => ({fill: currentColor,points: `${pos.x + 0.5},${pos.y} ${pos.x + 0.25},${pos.y + 0.5} ${pos.x - 0.25},${pos.y + 0.5} ${pos.x - 0.5},${pos.y} ${pos.x - 0.25},${pos.y - 0.5} ${pos.x + 0.25},${pos.y - 0.5}`})};function generatePolygonPoints(centerX, centerY, width, height, sides, offset = 0) {const points = [];for (let i = 0; i < sides; i++) {const angle = (i * 2 * Math.PI) / sides - Math.PI / 2 + offset;const x = Math.round(centerX + (width / 2) * Math.cos(angle));const y = Math.round(centerY + (height / 2) * Math.sin(angle));points.push(x, y);}return points.join(',');}function isWithinCanvas(pos) {return pos.x >= 10 && pos.x <= 10 + 980 &&pos.y >= 90 && pos.y <= 90 + 900;}function isWithinBrushRadius(currentPos, lastPos) {if (!lastPos) return false;const dx = currentPos.x - lastPos.x;const dy = currentPos.y - lastPos.y;const distance = Math.sqrt(dx * dx + dy * dy);return distance < currentBrushSize / 2;}function resetPolylineState() {finalizeShape();currentShapeElement = null;polylinePoints = [];}function updateBrushSizeFromSlider(x) {const trackRect = brushSliderTrack.getBoundingClientRect();const trackLeft = trackRect.left;const trackWidth = trackRect.width;let relativeX = x - trackLeft;relativeX = Math.max(0, Math.min(relativeX, trackWidth));const brushSize = Math.round(8 + (relativeX / trackWidth) * 32);const sliderX = 305 + (relativeX / trackWidth) * 110;const handleRadius = Math.max(4, Math.min(20, brushSize * 0.5));brushSlider.setAttribute('cx', sliderX);brushSlider.setAttribute('r', handleRadius);currentBrushSize = brushSize;}function startSliderDrag(evt) {finalizeShape();isDraggingSlider = true;updateBrushSizeFromSlider(evt.clientX);}function updateSliderDrag(evt) {if (isDraggingSlider) {updateBrushSizeFromSlider(evt.clientX);}}function stopSliderDrag() {isDraggingSlider = false;}document.querySelectorAll('.color-btn').forEach(btn => {btn.addEventListener('click', function() {setActiveElement('.color-btn', this);currentColor = this.getAttribute('fill');});});brushSlider.addEventListener('mousedown', startSliderDrag);brushSliderTrack.addEventListener('mousedown', startSliderDrag);document.addEventListener('mousemove', updateSliderDrag);document.addEventListener('mouseup', stopSliderDrag);brushSlider.addEventListener('touchstart', function(evt) {evt.preventDefault();finalizeShape();isDraggingSlider = true;updateBrushSizeFromSlider(evt.touches[0].clientX);}, {passive: false});brushSliderTrack.addEventListener('touchstart', function(evt) {evt.preventDefault();finalizeShape();isDraggingSlider = true;updateBrushSizeFromSlider(evt.touches[0].clientX);}, {passive: false});document.addEventListener('touchmove', function(evt) {if (isDraggingSlider) {evt.preventDefault();updateBrushSizeFromSlider(evt.touches[0].clientX);}});document.addEventListener('touchend', stopSliderDrag);document.querySelectorAll('.tool-group').forEach((group, index) => {group.addEventListener('click', function() {setActiveElement('.tool-bg', this.querySelector('.tool-bg'));setActiveElement('.shape-group .tool-bg', null);const tools = ['brush', 'eraser', 'bucket'];currentTool = tools[index] || 'brush';});});document.querySelectorAll('.shape-group').forEach((group) => {group.addEventListener('click', function() {setActiveElement('.shape-group .tool-bg', this.querySelector('.tool-bg'));setActiveElement('.tool-group .tool-bg', null);const shapeType = this.querySelector('.tool-bg').getAttribute('data-shape');currentTool = 'shape';currentShape = shapeType;if (currentShape === 'polyline') {polylinePoints = [];}});});function isFillCanvas(element) {if (element.tagName.toLowerCase() !== 'rect') return false;const x = parseInt(element.getAttribute('x'));const y = parseInt(element.getAttribute('y'));const width = parseInt(element.getAttribute('width'));const height = parseInt(element.getAttribute('height'));return x === 10 && y === 90 && width === 980 && height === 900;}function onlyPathIsClear() {return paths.length === 1 &&isFillCanvas(paths[0]) &&paths[0].getAttribute('fill') === '#ffffff';}function saveDrawing(storageKey = localStorageKey) {const drawingElements = [];const children = Array.from(drawingArea.children);let fillElement = null;for (let i = children.length - 1; i >= 0; i--) {const element = children[i];const stroke = element.getAttribute('stroke') ? hexToBytes3(element.getAttribute('stroke')) : null;const fill = element.getAttribute('fill') !== '#none' ? hexToBytes3(element.getAttribute('fill')) : null;const color = stroke || fill || '0x000000';const elementData = {shape: getElementShape(element),color: color,stroke: parseInt(element.getAttribute('stroke-width') || '0'),points: extractPoints(element)};drawingElements.unshift(elementData);if (isFillCanvas(element)) {fillElement = element;if (element.getAttribute('fill') === '#ffffff') {drawingElements.shift();}break;}}if (drawingElements.length > 0) {if (storageKey) localStorage.setItem(storageKey, JSON.stringify(drawingElements));} else {localStorage.removeItem(storageKey);}return drawingElements.length > 0 ? drawingElements : null;}function getElementShape(element) {const tagName = element.tagName.toLowerCase();const shapeMap = {'rect': 0, 'line': 1, 'ellipse': 2, 'polyline': 3, 'polygon': 4, 'path': 5};return shapeMap[tagName] || 0;}function hexToBytes3(hexColor) {return hexColor ? hexColor.replace('#', '0x') : null;}function bytes3ToHex(bytes3) {const cleanHex = bytes3.replace('0x', '');return '#' + cleanHex;}function extractPoints(element) {const tagName = element.tagName.toLowerCase();const points = [];switch (tagName) {case 'rect':const x = parseInt(element.getAttribute('x'));const y = parseInt(element.getAttribute('y'));const width = parseInt(element.getAttribute('width'));const height = parseInt(element.getAttribute('height'));points.push({ x: x, y: y }, { x: width, y: height });break;case 'ellipse':const cx = parseInt(element.getAttribute('cx'));const cy = parseInt(element.getAttribute('cy'));const rx = parseInt(element.getAttribute('rx'));const ry = parseInt(element.getAttribute('ry'));points.push({ x: cx, y: cy }, { x: rx, y: ry });break;case 'line':points.push({ x: parseInt(element.getAttribute('x1')), y: parseInt(element.getAttribute('y1')) },{ x: parseInt(element.getAttribute('x2')), y: parseInt(element.getAttribute('y2')) });break;case 'polyline':case 'polygon':points.push(...extractShapePoints(element));break;case 'path':points.push(...extractPathPoints(element));break;}return points;}function extractShapePoints(element) {const points = [];const pointsAttr = element.getAttribute('points');const coords = pointsAttr.split(/[,\s]+/);for (let i = 0; i < coords.length; i += 2) {points.push({x: parseInt(coords[i]),y: parseInt(coords[i + 1])});}return points;}function extractPathPoints(element) {const points = [];const d = element.getAttribute('d');const commands = d.match(/[ML][\d.-]+\s+[\d.-]+/g) || [];commands.forEach(cmd => {const parts = cmd.trim().split(/\s+/);if (parts.length >= 2) {const x = parseInt(parts[0].substring(1));const y = parseInt(parts[1]);points.push({ x: x, y: y });}});return points;}function loadDrawing() {const savedData = localStorage.getItem(localStorageKey);const tokenData = saveDrawing('tokenArt');if (tokenData) {sendMessageToParent('LOAD_DATA', { loadType: 'token', artData: tokenData });}if (savedData) {const savedObjects = JSON.parse(savedData);drawingArea.innerHTML = '';paths = [];savedObjects.forEach(obj => {const element = createElementFromContract(obj);if (element) {drawingArea.appendChild(element);paths.push(element);}});sendMessageToParent('LOAD_DATA', { loadType: 'local', artData: savedObjects });}}function createElementFromContract(obj) {const element = document.createElementNS(SVG_NS, getElementTag(obj.shape));switch (obj.shape) {case 0:const [pos, size] = obj.points;rectAttrs = {x: pos.x,y: pos.y,width: size.x,height: size.y,fill: bytes3ToHex(obj.color)};Object.entries(rectAttrs).forEach(([key, value]) => {element.setAttribute(key, value);});break;case 1:const [start, end] = obj.points;const lineAttrs = {x1: start.x, y1: start.y, x2: end.x, y2: end.y,stroke: bytes3ToHex(obj.color), 'stroke-width': obj.stroke};Object.entries(lineAttrs).forEach(([key, value]) => {element.setAttribute(key, value);});break;case 2:const [center, radius] = obj.points;const ellipseAttrs = {cx: center.x, cy: center.y, rx: radius.x, ry: radius.y,fill: bytes3ToHex(obj.color)};Object.entries(ellipseAttrs).forEach(([key, value]) => {element.setAttribute(key, value);});break;case 3:const polylineAttrs = {points: obj.points.map(p => `${p.x},${p.y}`).join(' '),fill: 'none',stroke: bytes3ToHex(obj.color),'stroke-width': obj.stroke};Object.entries(polylineAttrs).forEach(([key, value]) => {element.setAttribute(key, value);});break;case 4:const polygonAttrs = {points: obj.points.map(p => `${p.x},${p.y}`).join(' '),fill: bytes3ToHex(obj.color)};Object.entries(polygonAttrs).forEach(([key, value]) => {element.setAttribute(key, value);});break;case 5:const pathAttrs = {d: obj.points.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`).join(''),fill: 'none',stroke: bytes3ToHex(obj.color),'stroke-width': obj.stroke,'stroke-linecap': 'round','stroke-linejoin': 'round'};Object.entries(pathAttrs).forEach(([key, value]) => {element.setAttribute(key, value);});break;}return element;}function getElementTag(shape) {const tags = ['rect', 'line', 'ellipse', 'polyline', 'polygon', 'path'];return tags[shape] || 'path';}function exportDrawing() {const contractObjects = saveDrawing();if (!contractObjects) return;const svgElements = contractObjects.map(obj => {const element = createElementFromContract(obj);return element.outerHTML;}).join('');const svgContent = `<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="980" height="900" viewBox="0 0 980 900"><rect width="980" height="900" fill="white" />${svgElements}</svg>`;const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgContent);const link = document.createElementNS(XHTML_NS, 'a');link.href = dataUrl;link.download = 'painting.svg';link.click();}function getDiff(baseArt = localStorage.getItem('tokenArt'), currentArt = localStorage.getItem(localStorageKey)) {if (!baseArt) {return { saveType: 'set', diff: currentArt };} else if (baseArt === currentArt) {return { saveType: 'set', diff: null };} else if (currentArt.startsWith(baseArt.slice(0, -2))) {const baseArtJson = baseArt ? JSON.parse(baseArt) : [];const currentArtJson = currentArt ? JSON.parse(currentArt) : [];const diff = currentArtJson.slice(baseArtJson.length);return { saveType: 'append', diff: JSON.stringify(diff) };}return { saveType: 'set', diff: currentArt };}function undo() {if (paths.length > 0) {const lastPath = paths.pop();drawingArea.removeChild(lastPath);sendArtModifiedMessage('undo');if (redoStack.length === 0) {document.querySelector('.action-bg.redo').classList.remove('inactive');}redoStack.push(lastPath);if (redoStack.length > MAX_REDO_STACK) {redoStack.shift();}if (paths.length === 0 || onlyPathIsClear()) {document.querySelector('.action-bg.undo').classList.add('inactive');}}}function redo() {if (redoStack.length > 0) {const lastPath = redoStack.pop();drawingArea.appendChild(lastPath);if (paths.length === 0 || onlyPathIsClear()) {document.querySelector('.action-bg.undo').classList.remove('inactive');}paths.push(lastPath);sendArtModifiedMessage('redo');}if (redoStack.length === 0) {document.querySelector('.action-bg.redo').classList.add('inactive');}}document.querySelectorAll('.action-group').forEach((group, index) => {group.addEventListener('click', function() {if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {finalizeShape();}const actions = [() => undo(),() => redo(),() => {fillCanvas('#ffffff');saveDrawing();},() => {const tokenArtString = localStorage.getItem('tokenArt');const saveData = saveDrawing();const { saveType, diff } = getDiff();sendMessageToParent('SAVE_REQUEST', { saveType: saveType, artData: diff });},() => exportDrawing()];if (actions[index]) actions[index]();});});function fillCanvas(color) {const fillRect = createSVGElement('rect', {x: 10, y: 90, width: 980, height: 900, fill: color});drawingArea.appendChild(fillRect);paths.push(fillRect);sendArtModifiedMessage(color === '#ffffff' ? 'clear' : 'fill');}function startDrawing(pos) {if (!isWithinCanvas(pos)) return;if (redoStack.length > 0) {redoStack = [];document.querySelector('.action-bg.redo').classList.add('inactive');}if (currentTool === 'bucket') {fillCanvas(currentColor);return;}if (currentTool === 'shape') {if (currentShape === 'polyline') {addPolylinePoint(pos);return;} else {startPos = pos;createShapeStart(pos);return;}}isDrawing = true;lastDrawPos = pos;currentPath = createSVGElement('path', {stroke: currentTool === 'eraser' ? '#ffffff' : currentColor,'stroke-width': currentBrushSize,fill: 'none','stroke-linecap': 'round','stroke-linejoin': 'round',d: `M${pos.x} ${pos.y} L${pos.x} ${pos.y}`});drawingArea.appendChild(currentPath);paths.push(currentPath);}function createShapeStart(pos) {isDrawing = true;const config = shapeConfigs[currentShape];if (config) {const shape = createSVGElement(currentShape === 'line' ? 'line' :currentShape.startsWith('polygon') ? 'polygon' : currentShape, config(pos));drawingArea.appendChild(shape);currentShapeElement = shape;}}function updateShape(pos) {if (!currentShapeElement || !startPos) return;const deltaX = pos.x - startPos.x;const deltaY = pos.y - startPos.y;const absWidth = Math.abs(deltaX);const absHeight = Math.abs(deltaY);const centerX = (startPos.x + pos.x) / 2;const centerY = (startPos.y + pos.y) / 2;switch (currentShape) {case 'rect':const rectAttrs = {x: Math.min(startPos.x, pos.x),y: Math.min(startPos.y, pos.y),width: absWidth,height: absHeight};Object.entries(rectAttrs).forEach(([key, value]) => {currentShapeElement.setAttribute(key, value);});break;case 'ellipse':const ellipseAttrs = {cx: centerX,cy: centerY,rx: absWidth / 2,ry: absHeight / 2};Object.entries(ellipseAttrs).forEach(([key, value]) => {currentShapeElement.setAttribute(key, value);});break;case 'line':currentShapeElement.setAttribute('x2', pos.x);currentShapeElement.setAttribute('y2', pos.y);break;case 'polygon-3':case 'polygon-5':case 'polygon-6':const sides = parseInt(currentShape.split('-')[1]);let offset = pos.y > startPos.y ? Math.PI : 0;if (sides === 6) {offset += Math.PI / 2;}const points = generatePolygonPoints(centerX, centerY, absWidth, absHeight, sides, offset);currentShapeElement.setAttribute('points', points);break;}}function addPolylinePoint(pos) {polylinePoints.push(pos.x, pos.y);if (polylinePoints.length >= 1000) {const lastX = polylinePoints[polylinePoints.length - 4];const lastY = polylinePoints[polylinePoints.length - 3];finalizeShape();polylinePoints = [lastX, lastY, pos.x, pos.y];currentShapeElement = createSVGElement('polyline', {points: polylinePoints.join(','),fill: 'none',stroke: currentColor,'stroke-width': currentBrushSize});drawingArea.appendChild(currentShapeElement);} else {if (!currentShapeElement) {currentShapeElement = createSVGElement('polyline', {points: polylinePoints.join(','),fill: 'none',stroke: currentColor,'stroke-width': currentBrushSize});drawingArea.appendChild(currentShapeElement);} else {currentShapeElement.setAttribute('points', polylinePoints.join(','));}}}function sendArtModifiedMessage(message) {const currentArt = JSON.stringify(saveDrawing(null));const diff = getDiff(localStorage.getItem('tokenArt'), currentArt);sendMessageToParent('ART_MODIFIED', { message, artData: diff });}function finalizeShape() {const shape = currentShapeElement;if (shape) {paths.push(shape);sendArtModifiedMessage(currentShape);}if (polylinePreview) {polylinePreview.remove();polylinePreview = null;}if (shape && shape.tagName === 'polyline') {polylinePoints = [];currentShapeElement = null;if (paths.length > 0 && !onlyPathIsClear()) {document.querySelector('.action-bg.undo').classList.remove('inactive');}}}function draw(pos) {if (!isDrawing) return;if (currentTool === 'shape' && currentShapeElement && startPos) {updateShape(pos);return;}if (!currentPath || !isWithinCanvas(pos)) return;const currentD = currentPath.getAttribute('d');const pathPoints = currentD.match(/[ML]\s*[\d.-]+\s+[\d.-]+/g) || [];if (pathPoints.length >= 500) {const lastPoint = pathPoints[pathPoints.length - 1];const coords = lastPoint.split(' ');const lastX = coords[0].slice(1);const lastY = coords[1];currentPath = createSVGElement('path', {stroke: currentTool === 'eraser' ? '#ffffff' : currentColor,'stroke-width': currentBrushSize,fill: 'none','stroke-linecap': 'round','stroke-linejoin': 'round',d: `M${lastX} ${lastY} L${pos.x} ${pos.y}`});drawingArea.appendChild(currentPath);paths.push(currentPath);sendArtModifiedMessage(currentTool);} else {currentPath.setAttribute('d', currentD + `L${pos.x} ${pos.y}`);}}function setRedoButtonState() {if (redoStack.length === 0) {document.querySelector('.action-bg.redo').classList.add('inactive');} else {document.querySelector('.action-bg.redo').classList.remove('inactive');}}function stopDrawing() {if (currentTool === 'shape' && currentShapeElement && startPos) {finalizeShape();} else if (isDrawing && currentPath && currentTool !== 'shape') {sendArtModifiedMessage(currentTool);}isDrawing = false;currentPath = null;startPos = null;lastDrawPos = null;if (currentTool !== 'shape' || currentShape !== 'polyline') {currentShapeElement = null;}if (paths.length === 0 || onlyPathIsClear()) {document.querySelector('.action-bg.undo').classList.add('inactive');} else {document.querySelector('.action-bg.undo').classList.remove('inactive');}}canvas.addEventListener('mousedown', function(evt) {startDrawing(getMousePos(evt));});document.addEventListener('mousemove', function(evt) {if (isDrawing) {const currentPos = getMousePos(evt);if (isWithinBrushRadius(currentPos, lastDrawPos)) {return;} else {draw(currentPos);lastDrawPos = currentPos;}}if (currentTool === 'shape' && currentShape === 'polyline' && polylinePoints.length > 0) {if (!polylinePreview) {polylinePreview = createSVGElement('line', {stroke: currentColor,'stroke-width': currentBrushSize,'stroke-dasharray': [currentBrushSize*2, currentBrushSize]});drawingArea.appendChild(polylinePreview);}const lastX = polylinePoints[polylinePoints.length - 2];const lastY = polylinePoints[polylinePoints.length - 1];const pos = getMousePos(evt);const previewAttrs = { x1: lastX, y1: lastY, x2: pos.x, y2: pos.y };Object.entries(previewAttrs).forEach(([key, value]) => {polylinePreview.setAttribute(key, value);});if (!isWithinCanvas(pos)) {polylinePreview.remove();polylinePreview = null;}}});document.addEventListener('mouseup', stopDrawing);canvas.addEventListener('touchstart', function(evt) {evt.preventDefault();startDrawing(getTouchPos(evt));}, { passive: false });canvas.addEventListener('touchmove', function(evt) {evt.preventDefault();const currentPos = getTouchPos(evt);if (isWithinBrushRadius(currentPos, lastDrawPos)) {return;}draw(currentPos);lastDrawPos = currentPos;}, { passive: false });canvas.addEventListener('touchend', function(evt) {evt.preventDefault();stopDrawing();}, { passive: false });document.addEventListener('click', function(evt) {if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {if (!isWithinCanvas(getMousePos(evt))) {resetPolylineState();}}});document.addEventListener('touchend', function(evt) {if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {const touch = evt.changedTouches[0];if (!isWithinCanvas(getTouchPos(evt))) {resetPolylineState();}}});canvas.addEventListener('dblclick', function(evt) {evt.preventDefault();if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {resetPolylineState();}});function sendMessageToParent(type, data = {}) {console.log('sent message to parent: ', type, data);if (window.parent && window.parent !== window) {window.parent.postMessage({ type, data }, '*');}}window.addEventListener('load', function() {updateCoordinateFactors();loadDrawing();if (paths.length > 0 && !onlyPathIsClear()) {document.querySelector('.action-bg.undo').classList.remove('inactive');}const initialBrushSize = currentBrushSize;const sliderX = 305 + ((initialBrushSize - 8) / 32) * 110;const initialHandleRadius = Math.max(4, Math.min(20, initialBrushSize * 0.5));brushSlider.setAttribute('cx', sliderX);brushSlider.setAttribute('r', initialHandleRadius);});]]></script></svg>