<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="1000" height="1000" viewBox="0 0 1000 1000">
  <defs>
    <style>
      .toolbar {fill: #f0f0f0; stroke: #ccc; stroke-width: 1;}
      .canvas {fill: white; stroke: #ccc; stroke-width: 1;}
      #drawing-area {pointer-events: none;}
      text {font-family: Arial, sans-serif; font-size: 14px; fill: #333;}
      .toolbar-text { 
        font-size: 12px; 
        user-select: none; 
        -webkit-user-select: none; 
        -moz-user-select: none; 
        -ms-user-select: none; 
      }
      .button-text { 
        font-size: 20px; 
        fill: white; 
        pointer-events: none; 
        user-select: none; 
        -webkit-user-select: none; 
        -moz-user-select: none; 
        -ms-user-select: none; 
      }
      .color-btn, .brush-size, .tool-bg, .action-bg {cursor: pointer;}
      .color-btn {stroke: #333; stroke-width: 2;}
      .color-btn:hover {stroke: #777; stroke-width: 3;}
      .color-btn.active {stroke: #000; stroke-width: 3;}
      #brush-slider-handle {cursor: grab;}
      #brush-slider-handle:active {cursor: grabbing;}
      #brush-slider-track {cursor: pointer;}
      .tool-button { 
        font-size: 20px; 
        fill: #666; 
        transition: fill 0.2s; 
        user-select: none; 
        -webkit-user-select: none; 
        -moz-user-select: none; 
        -ms-user-select: none; 
      }
      .tool-button:hover {fill: #333;}
      .tool-button.active {fill: #333;}
      .tool-bg {fill: #f0f0f0; stroke: #ccc; stroke-width: 1; rx: 5; ry: 5;}
      .tool-bg:hover {fill: #e0e0e0; stroke: #999;}
      .tool-bg.active {fill: #333; stroke: #333;}
      .tool-bg.active:hover {fill: #444; stroke: #444;}
      .tool-group {cursor: pointer;}
      .tool-group:hover .tool-bg {fill: #e0e0e0; stroke: #999;}
      .tool-group:hover .tool-bg.active {fill: #444; stroke: #444;}
      .shape-group {cursor: pointer;}
      .shape-group:hover .tool-bg {fill: #e0e0e0; stroke: #999;}
      .shape-group:hover .tool-bg.active {fill: #444; stroke: #444;}
      .shape-group .tool-bg.active ~ .shape-icon {stroke: white !important;}
      .shape-btn { cursor: pointer; }
      .action-bg {fill: #f0f0f0; stroke: #ccc; stroke-width: 1; rx: 5; ry: 5;}
      .action-bg:hover {fill: #e0e0e0; stroke: #999;}
      .action-bg.undo {fill: #fff3e0; stroke: #ffcc02;}
      .action-bg.undo:hover {fill: #ffcc02; stroke: #ffa000;}
      .action-bg.redo {fill: #f3e5f5; stroke: #ce93d8;}
      .action-bg.redo:hover {fill: #ce93d8; stroke: #ba68c8;}
      .action-bg.clear {fill: #ffebee; stroke: #ffcdd2;}
      .action-bg.clear:hover {fill: #ffcdd2; stroke: #ef9a9a;}
      .action-bg.save {fill: #e8f5e8; stroke: #c8e6c9;}
      .action-bg.save:hover {fill: #c8e6c9; stroke: #a5d6a7;}
      .action-bg.export {fill: #e3f2fd; stroke: #bbdefb;}
      .action-bg.export:hover {fill: #bbdefb; stroke: #90caf9;}
      .action-bg.inactive {fill: #f5f5f5 !important; stroke: #e0e0e0 !important;}
      .action-bg.inactive:hover {fill: #f5f5f5 !important; stroke: #e0e0e0 !important;}
      .button-text.inactive {fill: #bdbdbd !important;}
    </style>
    <rect id="canvas-bg" x="10" y="90" width="980" height="900" rx="5"/>
    <clipPath id="canvas-clip">
      <use href="#canvas-bg"/>
    </clipPath>
  </defs>
  
  <!-- Background -->
  <rect width="1000" height="1000" fill="#e8e8e8"/>

  <!-- Canvas -->
  <use href="#canvas-bg" class="canvas"/>
  
  <!-- Toolbar -->
  <rect x="10" y="10" width="980" height="70" class="toolbar" rx="5"/>

  <!-- Brush size controls -->
  <g id="brush-size-controls">
    <rect x="300" y="25" width="120" height="20" fill="#f0f0f0" stroke="#ccc" stroke-width="1" rx="10"/>
    <rect id="brush-slider-track" x="305" y="27.5" width="110" height="15" fill="#ddd" rx="7.5"/>
    <circle id="brush-slider-handle" cx="310" cy="35" r="8" fill="#4CAF50" stroke="#45a049" stroke-width="2" cursor="pointer"/>
  </g>
  
  <!-- Color palette -->
  <circle cx="50" cy="35" r="15" class="color-btn active" fill="#000000"/>
  
  <!-- Dynamic Content Start -->
  <circle cx="90" cy="35" r="15" class="color-btn" fill="#ff0000"/>
  <circle cx="130" cy="35" r="15" class="color-btn" fill="#0000ff"/>
  <circle cx="170" cy="35" r="15" class="color-btn" fill="#00ff00" />
  <circle cx="210" cy="35" r="15" class="color-btn" fill="#ffff00" />
  <circle cx="250" cy="35" r="15" class="color-btn" fill="#ff00ff" />

  <g class="shape-group" transform="translate(445, 20)">
    <rect data-shape="line" x="0" y="0" width="30" height="30" class="tool-bg"/>
    <line x1="5" y1="10" x2="25" y2="20" stroke="#333" stroke-width="2" class="shape-icon"/>
  </g>
  <g class="shape-group" transform="translate(485, 20)">
    <rect data-shape="polyline" x="0" y="0" width="30" height="30" class="tool-bg"/>
    <polyline points="5,15 12.5,10 17.5,20 25,15" fill="none" stroke="#333" stroke-width="2" class="shape-icon"/>
  </g>
  <g class="shape-group" transform="translate(525, 20)">
    <rect data-shape="polygon-3" x="0" y="0" width="30" height="30" class="tool-bg"/>
    <polygon points="15,7 25,23 5,23" fill="none" stroke="#333" stroke-width="2" class="shape-icon"/>
  </g>

  <!-- Drawing area -->
  <g id="drawing-area" clip-path="url(#canvas-clip)" data-token="0">
  </g>
  <!-- Dynamic Content End -->
  
  <!-- Tool buttons -->
  <g class="tool-group">
    <rect x="575" y="20" width="30" height="30" class="tool-bg active"/>
    <text x="590" y="40" text-anchor="middle" class="tool-button">üñåÔ∏è</text>
  </g>
  
  <g class="tool-group">
    <rect x="615" y="20" width="30" height="30" class="tool-bg"/>
    <text x="630" y="40" text-anchor="middle" class="tool-button">üßΩ</text>
  </g>
  
  <g class="tool-group">
    <rect x="655" y="20" width="30" height="30" class="tool-bg"/>
    <text x="670" y="40" text-anchor="middle" class="tool-button">ü™£</text>
  </g>
  
  <!-- Action buttons -->
  <!-- Action buttons -->
  <g class="action-group">
    <rect x="720" y="20" width="40" height="30" class="action-bg undo inactive"/>
    <text x="740" y="40" text-anchor="middle" class="button-text inactive">‚Ü∂</text>
    <text x="740" y="65" text-anchor="middle" class="toolbar-text">Undo</text>
  </g>
  
  <g class="action-group">
    <rect x="770" y="20" width="40" height="30" class="action-bg redo inactive"/>
    <text x="790" y="40" text-anchor="middle" class="button-text inactive">‚Ü∑</text>
    <text x="790" y="65" text-anchor="middle" class="toolbar-text">Redo</text>
  </g>
  
  <g class="action-group">
    <rect x="820" y="20" width="40" height="30" class="action-bg clear"/>
    <text x="840" y="40" text-anchor="middle" class="button-text">üí£</text>
    <text x="840" y="65" text-anchor="middle" class="toolbar-text">Clear</text>
  </g>
  
  <g class="action-group">
    <rect x="870" y="20" width="40" height="30" class="action-bg save"/>
    <text x="890" y="40" text-anchor="middle" class="button-text">üíæ</text>
    <text x="890" y="65" text-anchor="middle" class="toolbar-text">Save</text>
  </g>
  
  <g class="action-group">
    <rect x="920" y="20" width="40" height="30" class="action-bg export"/>
    <text x="940" y="40" text-anchor="middle" class="button-text">üìÅ</text>
    <text x="940" y="65" text-anchor="middle" class="toolbar-text">Export</text>
  </g>
  
  <!-- Labels -->
  <text x="150" y="65" text-anchor="middle" class="toolbar-text">Colors</text>
  <text x="350" y="65" text-anchor="middle" class="toolbar-text">Brush Size</text>
  <text x="500" y="65" text-anchor="middle" class="toolbar-text">Shapes</text>
  <text x="630" y="65" text-anchor="middle" class="toolbar-text">Tools</text>

  <script type="text/javascript">
    <![CDATA[
      // Application constants - namespaces
      const SVG_NS = 'http://www.w3.org/2000/svg';
      const XHTML_NS = 'http://www.w3.org/1999/xhtml';

      // Cached DOM elements for performance optimization
      const drawingArea = document.getElementById('drawing-area');
      const canvas = document.querySelector('.canvas');
      const svg = document.querySelector('svg');
      const brushSlider = document.getElementById('brush-slider-handle');
      const brushSliderTrack = document.getElementById('brush-slider-track');

      // Application state variables
      const localStorageKey = 'colourMeArt.' + (drawingArea.getAttribute('data-token') || '0');
      let isDrawing = false;
      let isDraggingSlider = false;
      let currentColor = '#000000';
      let currentBrushSize = 8;
      let currentTool = 'brush'; // 'brush', 'eraser', 'bucket', 'shape'
      let currentShape = 'rect'; // 'rect', 'ellipse', 'polygon', 'line', 'polyline'
      let paths = [];
      let currentPath = null;
      let startPos = null;
      let currentShapeElement = null;
      let polylinePoints = [];
      let polylinePreview = null;
      let mouseMoveThrottle = null;
      let lastDrawPos = null;

      // Coordinate conversion cache for performance
      let svgRect = null;
      let svgWidth = 1000;
      let svgHeight = 1000;
      let displayWidth = 1000;
      let displayHeight = 1000;

      let redoStack = [];
      const MAX_REDO_STACK = 100;

      // Update coordinate conversion factors when window resizes
      function updateCoordinateFactors() {
        svgRect = svg.getBoundingClientRect();
        svgWidth = svg.viewBox.baseVal.width;
        svgHeight = svg.viewBox.baseVal.height;
        displayWidth = svgRect.width;
        displayHeight = svgRect.height;
      }

      // Optimized position calculation with coordinate transformation
      function calculatePosition(clientX, clientY) {
        if (!svgRect) updateCoordinateFactors();
        const x = clientX - svgRect.left;
        const y = clientY - svgRect.top;
        const rawX = (x * svgWidth) / displayWidth;
        const rawY = (y * svgHeight) / displayHeight;
        return {
          x: Math.round(rawX),
          y: Math.round(rawY)
        };
      }

      // Unified position getters for input events
      function getMousePos(evt) {
        return calculatePosition(evt.clientX, evt.clientY);
      }

      function getTouchPos(evt) {
        const touch = evt.touches[0];
        return calculatePosition(touch.clientX, touch.clientY);
      }

      // Optimized SVG element creation with batch attribute setting
      function createSVGElement(tagName, attributes = {}) {
        const element = document.createElementNS(SVG_NS, tagName);
        Object.entries(attributes).forEach(([key, value]) => {
          element.setAttribute(key, value);
        });
        return element;
      }

      // Optimized class manipulation for UI state changes
      function setActiveElement(selector, activeElement) {
        document.querySelectorAll(selector).forEach(el => el.classList.remove('active'));
        if (activeElement) activeElement.classList.add('active');
      }

      // Shape configuration templates for efficient shape creation
      const shapeConfigs = {
        rect: (pos) => ({
          fill: currentColor, x: pos.x, y: pos.y, width: 1, height: 1
        }),
        ellipse: (pos) => ({
          fill: currentColor, cx: pos.x, cy: pos.y, rx: 1, ry: 1
        }),
        line: (pos) => ({
          stroke: currentColor, 'stroke-width': currentBrushSize, 
          x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y
        }),
        'polygon-3': (pos) => ({
          fill: currentColor,
          points: `${pos.x},${pos.y} ${pos.x + 1},${pos.y + 1} ${pos.x - 1},${pos.y + 1}`
        }),
        'polygon-5': (pos) => ({
          fill: currentColor,
          points: `${pos.x},${pos.y - 0.5} ${pos.x + 0.5},${pos.y - 0.3} ${pos.x + 0.3},${pos.y + 0.5} ${pos.x - 0.3},${pos.y + 0.5} ${pos.x - 0.5},${pos.y - 0.3}`
        }),
        'polygon-6': (pos) => ({
          fill: currentColor,
          points: `${pos.x + 0.5},${pos.y} ${pos.x + 0.25},${pos.y + 0.5} ${pos.x - 0.25},${pos.y + 0.5} ${pos.x - 0.5},${pos.y} ${pos.x - 0.25},${pos.y - 0.5} ${pos.x + 0.25},${pos.y - 0.5}`
        })
      };

      // Optimized polygon point generation for regular polygons
      function generatePolygonPoints(centerX, centerY, width, height, sides, offset = 0) {
        const points = [];
        for (let i = 0; i < sides; i++) {
          const angle = (i * 2 * Math.PI) / sides - Math.PI / 2 + offset;
          const x = Math.round(centerX + (width / 2) * Math.cos(angle));
          const y = Math.round(centerY + (height / 2) * Math.sin(angle));
          points.push(x, y);
        }
        return points.join(',');
      }

      // Canvas boundary validation for drawing operations
      function isWithinCanvas(pos) {
        return pos.x >= 10 && pos.x <= 10 + 980 && 
               pos.y >= 90 && pos.y <= 90 + 900;
      }

      // **OPTIMIZATION: Unified distance calculation for brush radius filtering**
      function isWithinBrushRadius(currentPos, lastPos) {
        if (!lastPos) return false;
        const dx = currentPos.x - lastPos.x;
        const dy = currentPos.y - lastPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < currentBrushSize / 2;
      }

      // removed isOutsideCanvas and replaced with !isWithinCanvas

      // **OPTIMIZATION: Unified polyline cleanup function**
      function resetPolylineState() {
        finalizeShape();
        currentShapeElement = null;
        polylinePoints = [];
      }

      // Brush size slider functionality with optimized event handling
      function updateBrushSizeFromSlider(x) {
        const trackRect = brushSliderTrack.getBoundingClientRect();
        const trackLeft = trackRect.left;
        const trackWidth = trackRect.width;
        
        // Calculate position relative to track
        let relativeX = x - trackLeft;
        relativeX = Math.max(0, Math.min(relativeX, trackWidth));
        
        // Convert to brush size (8-40) and update elements
        const brushSize = Math.round(8 + (relativeX / trackWidth) * 32);
        const sliderX = 305 + (relativeX / trackWidth) * 110;
        const handleRadius = Math.max(4, Math.min(20, brushSize * 0.5));
        
        // Batch DOM updates for better performance
        brushSlider.setAttribute('cx', sliderX);
        brushSlider.setAttribute('r', handleRadius);
        currentBrushSize = brushSize;
      }
      
      function startSliderDrag(evt) {
        finalizeShape();
        isDraggingSlider = true;
        updateBrushSizeFromSlider(evt.clientX);
      }
      
      function updateSliderDrag(evt) {
        if (isDraggingSlider) {
          updateBrushSizeFromSlider(evt.clientX);
        }
      }
      
      function stopSliderDrag() {
        isDraggingSlider = false;
      }

      // Color palette event handling
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          setActiveElement('.color-btn', this);
          currentColor = this.getAttribute('fill');
        });
      });

      // Slider event listeners with touch support
      brushSlider.addEventListener('mousedown', startSliderDrag);
      brushSliderTrack.addEventListener('mousedown', startSliderDrag);
      document.addEventListener('mousemove', updateSliderDrag);
      document.addEventListener('mouseup', stopSliderDrag);
      
      // Touch events for slider with passive: false for preventDefault
      brushSlider.addEventListener('touchstart', function(evt) {
        evt.preventDefault();
        finalizeShape();
        isDraggingSlider = true;
        updateBrushSizeFromSlider(evt.touches[0].clientX);
      }, {passive: false});
      
      brushSliderTrack.addEventListener('touchstart', function(evt) {
        evt.preventDefault();
        finalizeShape();
        isDraggingSlider = true;
        updateBrushSizeFromSlider(evt.touches[0].clientX);
      }, {passive: false});
      
      document.addEventListener('touchmove', function(evt) {
        if (isDraggingSlider) {
          evt.preventDefault();
          updateBrushSizeFromSlider(evt.touches[0].clientX);
        }
      });
      
      document.addEventListener('touchend', stopSliderDrag);

      // Tool selection with optimized state management
      document.querySelectorAll('.tool-group').forEach((group, index) => {
        group.addEventListener('click', function() {
          setActiveElement('.tool-bg', this.querySelector('.tool-bg'));
          setActiveElement('.shape-group .tool-bg', null);
          
          const tools = ['brush', 'eraser', 'bucket'];
          currentTool = tools[index] || 'brush';
        });
      });

      // Shape selection with polyline state reset
      document.querySelectorAll('.shape-group').forEach((group) => {
        group.addEventListener('click', function() {
          setActiveElement('.shape-group .tool-bg', this.querySelector('.tool-bg'));
          setActiveElement('.tool-group .tool-bg', null);
          
          const shapeType = this.querySelector('.tool-bg').getAttribute('data-shape');
          currentTool = 'shape';
          currentShape = shapeType;

          if (currentShape === 'polyline') {
            polylinePoints = [];
          }
        });
      });

      function isFillCanvas(element) {
        // Check if element is a rect that covers the entire canvas
        if (element.tagName.toLowerCase() !== 'rect') return false;
        
        const x = parseInt(element.getAttribute('x'));
        const y = parseInt(element.getAttribute('y'));
        const width = parseInt(element.getAttribute('width'));
        const height = parseInt(element.getAttribute('height'));
        
        return x === 10 && y === 90 && width === 980 && height === 900;
      }

      function onlyPathIsClear() {
        return paths.length === 1 && 
               isFillCanvas(paths[0]) && 
               paths[0].getAttribute('fill') === '#ffffff';
      }

      // **OPTIMIZATION: Enhanced saveDrawing function with improved object creation**
      // passing in a null storageKey will not save to localStorage, but will return the drawingElements
      // Now processes from newest to oldest and stops at first canvas-covering element
      function saveDrawing(storageKey = localStorageKey) {
        const drawingElements = [];
        const children = Array.from(drawingArea.children);
        let fillElement = null;
        
        // Process from newest to oldest, stop at first canvas-covering element
        for (let i = children.length - 1; i >= 0; i--) {
          const element = children[i];
          
          // Create the element data
          const stroke = element.getAttribute('stroke') ? hexToBytes3(element.getAttribute('stroke')) : null;
          const fill = element.getAttribute('fill') !== '#none' ? hexToBytes3(element.getAttribute('fill')) : null;
          const color = stroke || fill || '0x000000';

          const elementData = {
            shape: getElementShape(element),
            color: color,
            stroke: parseInt(element.getAttribute('stroke-width') || '0'),
            points: extractPoints(element)
          };

          // Add to beginning of array (maintains newest-first order)
          drawingElements.unshift(elementData);
          
          if (isFillCanvas(element)) {
            console.log('Canvas-covering element found, stopping processing at index:', i);
            fillElement = element;
            if (element.getAttribute('fill') === '#ffffff') {
              drawingElements.shift(); // remove fill element if it's white
            }
            break;
          }
        }

        console.log('Final drawingElements:', drawingElements);

        // Store or delete drawingElements from localStorage
        if (drawingElements.length > 0) {
          if (storageKey) localStorage.setItem(storageKey, JSON.stringify(drawingElements));
        } else {
          localStorage.removeItem(storageKey);
        }
        
        return drawingElements.length > 0 ? drawingElements : null;
      }

      // Shape type mapping for contract compatibility
      function getElementShape(element) {
        const tagName = element.tagName.toLowerCase();
        const shapeMap = {
          'rect': 0, 'line': 1, 'ellipse': 2, 'polyline': 3, 'polygon': 4, 'path': 5
        };
        return shapeMap[tagName] || 0; // Default to rect
      }

      // Color format conversion for contract compatibility
      function hexToBytes3(hexColor) {
        return hexColor ? hexColor.replace('#', '0x') : null;
      }

      function bytes3ToHex(bytes3) {
        const cleanHex = bytes3.replace('0x', '');
        return '#' + cleanHex;
      }

      // **OPTIMIZATION: Consolidated point extraction with shared logic**
      function extractPoints(element) {
        const tagName = element.tagName.toLowerCase();
        const points = [];
        
        switch (tagName) {
          case 'rect':
            const x = parseInt(element.getAttribute('x'));
            const y = parseInt(element.getAttribute('y'));
            const width = parseInt(element.getAttribute('width'));
            const height = parseInt(element.getAttribute('height'));
            points.push({ x: x, y: y }, { x: width, y: height });
            break;
            
          case 'ellipse':
            const cx = parseInt(element.getAttribute('cx'));
            const cy = parseInt(element.getAttribute('cy'));
            const rx = parseInt(element.getAttribute('rx'));
            const ry = parseInt(element.getAttribute('ry'));
            points.push({ x: cx, y: cy }, { x: rx, y: ry });
            break;
            
          case 'line':
            points.push(
              { x: parseInt(element.getAttribute('x1')), y: parseInt(element.getAttribute('y1')) },
              { x: parseInt(element.getAttribute('x2')), y: parseInt(element.getAttribute('y2')) }
            );
            break;
            
          case 'polyline':
          case 'polygon':
            // **OPTIMIZATION: Unified function for both polyline and polygon points**
            points.push(...extractShapePoints(element));
            break;
            
          case 'path':
            points.push(...extractPathPoints(element));
            break;
        }
        
        return points;
      }

      // **OPTIMIZATION: Single function replaces extractPolylinePoints and extractPolygonPoints**
      function extractShapePoints(element) {
        const points = [];
        const pointsAttr = element.getAttribute('points');
        const coords = pointsAttr.split(/[,\s]+/);
        for (let i = 0; i < coords.length; i += 2) {
          points.push({ 
            x: parseInt(coords[i]), 
            y: parseInt(coords[i + 1]) 
          });
        }
        return points;
      }

      // Path point extraction for SVG path elements
      function extractPathPoints(element) {
        const points = [];
        const d = element.getAttribute('d');
        const commands = d.match(/[ML][\d.-]+\s+[\d.-]+/g) || [];
        
        commands.forEach(cmd => {
          const parts = cmd.trim().split(/\s+/);
          if (parts.length >= 2) {
            const x = parseInt(parts[0].substring(1));
            const y = parseInt(parts[1]);
            points.push({ x: x, y: y });
          }
        });
        
        return points;
      }

      // Load drawing data with optimized parsing
      function loadDrawing() {
        const savedData = localStorage.getItem(localStorageKey);
        const tokenData = saveDrawing('tokenArt');

        if (tokenData) {
          sendMessageToParent('LOAD_DATA', { loadType: 'token', artData: tokenData });
        }

        if (savedData) {
          const savedObjects = JSON.parse(savedData);
          drawingArea.innerHTML = '';
          paths = [];
          
          savedObjects.forEach(obj => {
            const element = createElementFromContract(obj);
            if (element) {
              drawingArea.appendChild(element);
              paths.push(element);
            }
          });

          sendMessageToParent('LOAD_DATA', { loadType: 'local', artData: savedObjects });
        }
      }

      // Create SVG elements from contract data with optimized attribute setting
      function createElementFromContract(obj) {
        const element = document.createElementNS(SVG_NS, getElementTag(obj.shape));
        
        // **OPTIMIZATION: Batch attribute setting based on shape type**
        switch (obj.shape) {
          case 0: // rect
            const [pos, size] = obj.points;
            rectAttrs = {
              x: pos.x,
              y: pos.y,
              width: size.x,
              height: size.y,
              fill: bytes3ToHex(obj.color)
            };
            Object.entries(rectAttrs).forEach(([key, value]) => {
              element.setAttribute(key, value);
            });
            break;

          case 1: // line
            const [start, end] = obj.points;
            const lineAttrs = {
              x1: start.x, y1: start.y, x2: end.x, y2: end.y,
              stroke: bytes3ToHex(obj.color), 'stroke-width': obj.stroke
            };
            Object.entries(lineAttrs).forEach(([key, value]) => {
              element.setAttribute(key, value);
            });
            break;
            
          case 2: // ellipse
            const [center, radius] = obj.points;
            const ellipseAttrs = {
              cx: center.x, cy: center.y, rx: radius.x, ry: radius.y,
              fill: bytes3ToHex(obj.color)
            };
            Object.entries(ellipseAttrs).forEach(([key, value]) => {
              element.setAttribute(key, value);
            });
            break;
            
          case 3: // polyline
            const polylineAttrs = {
              points: obj.points.map(p => `${p.x},${p.y}`).join(' '),
              fill: 'none',
              stroke: bytes3ToHex(obj.color),
              'stroke-width': obj.stroke
            };
            Object.entries(polylineAttrs).forEach(([key, value]) => {
              element.setAttribute(key, value);
            });
            break;
            
          case 4: // polygon
            const polygonAttrs = {
              points: obj.points.map(p => `${p.x},${p.y}`).join(' '),
              fill: bytes3ToHex(obj.color)
            };
            Object.entries(polygonAttrs).forEach(([key, value]) => {
              element.setAttribute(key, value);
            });
            break;
            
          case 5: // path
            const pathAttrs = {
              d: obj.points.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`).join(''),
              fill: 'none',
              stroke: bytes3ToHex(obj.color),
              'stroke-width': obj.stroke,
              'stroke-linecap': 'round',
              'stroke-linejoin': 'round'
            };
            Object.entries(pathAttrs).forEach(([key, value]) => {
              element.setAttribute(key, value);
            });
            break;
        }
        
        return element;
      }

      function getElementTag(shape) {
        const tags = ['rect', 'line', 'ellipse', 'polyline', 'polygon', 'path'];
        return tags[shape] || 'path';
      }

      // Optimized export function with efficient SVG generation
      function exportDrawing() {
        const contractObjects = saveDrawing();
        if (!contractObjects) return;
        
        const svgElements = contractObjects.map(obj => {
          const element = createElementFromContract(obj);
          return element.outerHTML;
        }).join('');
        
        const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="980" height="900" viewBox="0 0 980 900">
  <rect width="980" height="900" fill="white" />
  ${svgElements}
</svg>`;
        
        const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgContent);
        const link = document.createElementNS(XHTML_NS, 'a');
        link.href = dataUrl;
        link.download = 'painting.svg';
        link.click();
      }

      function getDiff(baseArt = localStorage.getItem('tokenArt'), currentArt = localStorage.getItem(localStorageKey)) {
        if (!baseArt) {
          const saveType = currentArt ? 'set' : 'none';
          return { saveType, diff: currentArt };
        } else if (baseArt === currentArt) {
          return { saveType: 'none', diff: "" };
        } else if (currentArt.startsWith(baseArt.slice(0, -2))) { // -2 to remove the trailing }]
          const baseArtJson = baseArt ? JSON.parse(baseArt) : [];
          const currentArtJson = currentArt ? JSON.parse(currentArt) : [];
          const diff = currentArtJson.slice(baseArtJson.length);
          return { saveType: 'append', diff: JSON.stringify(diff) };
        }
        // implied else for replace art
        return { saveType: 'set', diff: currentArt };
      }

      function undo() {
        if (paths.length > 0) {
          // remove last path from paths array
          const lastPath = paths.pop();
          drawingArea.removeChild(lastPath);
          sendArtModifiedMessage('undo');

          // if no redo paths previous, enable redo button
          if (redoStack.length === 0) {
            document.querySelector('.action-bg.redo').classList.remove('inactive');
          }

          // add last path to redo stack
          redoStack.push(lastPath);

          // if redo stack is too long, remove first path
          if (redoStack.length > MAX_REDO_STACK) {
            redoStack.shift();
          }

          // if no paths, disable undo button
          if (paths.length === 0 || onlyPathIsClear()) {
            document.querySelector('.action-bg.undo').classList.add('inactive');
          }
        }
      }

      function redo() {
        if (redoStack.length > 0) {
          const lastPath = redoStack.pop();
          drawingArea.appendChild(lastPath);

          // if no paths, re-enable the undo button
          if (paths.length === 0 || onlyPathIsClear()) {
            document.querySelector('.action-bg.undo').classList.remove('inactive');
          }
          paths.push(lastPath);
          sendArtModifiedMessage('redo');

        }
        if (redoStack.length === 0) {
          document.querySelector('.action-bg.redo').classList.add('inactive');
        }
      }

      // Action button handlers with optimized save logic
      document.querySelectorAll('.action-group').forEach((group, index) => {
        group.addEventListener('click', function() {
          const actions = [
            () => undo(), // Undo
            () => redo(), // Redo
            () => { // Clear
              fillCanvas('#ffffff');
              localStorage.removeItem(localStorageKey);
              sendMessageToParent('CLEAR_REQUEST');
            },
            () => { // Save
              const tokenArtString = localStorage.getItem('tokenArt');
              const saveData = saveDrawing();

              if (saveData) {
                const { saveType, diff } = getDiff();
                sendMessageToParent('SAVE_REQUEST', { saveType: saveType, artData: diff });
                console.log('saveRequest: ', saveType, diff.length);
              }
            },
            () => exportDrawing() // Export
          ];
          if (actions[index]) actions[index]();
        });
      });

      function fillCanvas(color) {
        const fillRect = createSVGElement('rect', {
          x: 10, y: 90, width: 980, height: 900, fill: color
        });
        drawingArea.appendChild(fillRect);
        paths.push(fillRect);
        sendArtModifiedMessage('fill');
      }

      // Drawing state management functions
      function startDrawing(pos) {
        if (!isWithinCanvas(pos)) return;
        if (redoStack.length > 0) {
          redoStack = [];
          document.querySelector('.action-bg.redo').classList.add('inactive');
        }
        if (currentTool === 'bucket') {
          fillCanvas(currentColor);
          return;
        }
        
        if (currentTool === 'shape') {
          if (currentShape === 'polyline') {
            addPolylinePoint(pos);
            return;
          } else {
            startPos = pos;
            createShapeStart(pos);
            return;
          }
        }
        
        // Standard brush/eraser drawing
        isDrawing = true;
        lastDrawPos = pos;
        currentPath = createSVGElement('path', {
          stroke: currentTool === 'eraser' ? '#ffffff' : currentColor,
          'stroke-width': currentBrushSize,
          fill: 'none',
          'stroke-linecap': 'round',
          'stroke-linejoin': 'round',
          d: `M${pos.x} ${pos.y} L${pos.x} ${pos.y}`
        });
        drawingArea.appendChild(currentPath);
        paths.push(currentPath);
      }

      function createShapeStart(pos) {
        isDrawing = true;
        const config = shapeConfigs[currentShape];
        if (config) {
          const shape = createSVGElement(currentShape === 'line' ? 'line' : 
            currentShape.startsWith('polygon') ? 'polygon' : currentShape, config(pos));
          drawingArea.appendChild(shape);
          currentShapeElement = shape;
        }
      }

      // **OPTIMIZATION: Improved shape updating with reduced calculations**
      function updateShape(pos) {
        if (!currentShapeElement || !startPos) return;
        
        // **OPTIMIZATION: Calculate common values once**
        const deltaX = pos.x - startPos.x;
        const deltaY = pos.y - startPos.y;
        const absWidth = Math.abs(deltaX);
        const absHeight = Math.abs(deltaY);
        const centerX = (startPos.x + pos.x) / 2;
        const centerY = (startPos.y + pos.y) / 2;
        
        switch (currentShape) {
          case 'rect':
            const rectAttrs = {
              x: Math.min(startPos.x, pos.x),
              y: Math.min(startPos.y, pos.y),
              width: absWidth,
              height: absHeight
            };
            Object.entries(rectAttrs).forEach(([key, value]) => {
              currentShapeElement.setAttribute(key, value);
            });
            break;
            
          case 'ellipse':
            const ellipseAttrs = {
              cx: centerX,
              cy: centerY,
              rx: absWidth / 2,
              ry: absHeight / 2
            };
            Object.entries(ellipseAttrs).forEach(([key, value]) => {
              currentShapeElement.setAttribute(key, value);
            });
            break;
            
          case 'line':
            currentShapeElement.setAttribute('x2', pos.x);
            currentShapeElement.setAttribute('y2', pos.y);
            break;
            
          case 'polygon-3':
          case 'polygon-5':
          case 'polygon-6':
            const sides = parseInt(currentShape.split('-')[1]);
            let offset = pos.y > startPos.y ? Math.PI : 0;
            // For hexagons, add œÄ/2 to rotate so points are at 3 and 9 o'clock
            if (sides === 6) {
              offset += Math.PI / 2;
            }
            const points = generatePolygonPoints(centerX, centerY, absWidth, absHeight, sides, offset);
            currentShapeElement.setAttribute('points', points);
            break;
        }
      }

      // Polyline point management with size limiting
      function addPolylinePoint(pos) {
        polylinePoints.push(pos.x, pos.y);
        
        // Limit polyline points to prevent performance issues
        if (polylinePoints.length >= 1000) {
          const lastX = polylinePoints[polylinePoints.length - 4];
          const lastY = polylinePoints[polylinePoints.length - 3];
          finalizeShape();
          polylinePoints = [lastX, lastY, pos.x, pos.y];
          currentShapeElement = createSVGElement('polyline', {
            points: polylinePoints.join(','),
            fill: 'none',
            stroke: currentColor,
            'stroke-width': currentBrushSize
          });
          drawingArea.appendChild(currentShapeElement);
        } else {
          if (!currentShapeElement) {
            currentShapeElement = createSVGElement('polyline', {
              points: polylinePoints.join(','),
              fill: 'none',
              stroke: currentColor,
              'stroke-width': currentBrushSize
            });
            drawingArea.appendChild(currentShapeElement);
          } else {
            currentShapeElement.setAttribute('points', polylinePoints.join(','));
          }
        }
      }

      // Unified function to send object added message
      function sendArtModifiedMessage(message) {
        const currentArt = JSON.stringify(saveDrawing(null));
        const diff = getDiff(localStorage.getItem('tokenArt'), currentArt);
        sendMessageToParent('ART_MODIFIED', { message, artData: diff });
        console.log('art modified: ', message, diff);
      }

      function finalizeShape() {
        const shape = currentShapeElement;
        if (shape) {
          paths.push(shape);
          sendArtModifiedMessage(currentShape);
        }
        if (polylinePreview) {
          polylinePreview.remove();
          polylinePreview = null;
        }
        // Reset polyline state when finalizing
        if (shape && shape.tagName === 'polyline') {
          polylinePoints = [];
          currentShapeElement = null;
        }
      }

      // **OPTIMIZATION: Improved draw function with path length limiting**
      function draw(pos) {
        if (!isDrawing) return;
        if (currentTool === 'shape' && currentShapeElement && startPos) {
          updateShape(pos);
          return;
        }
        if (!currentPath || !isWithinCanvas(pos)) return;
        
        // Limit path complexity for performance
        const currentD = currentPath.getAttribute('d');
        const pathPoints = currentD.match(/[ML]\s*[\d.-]+\s+[\d.-]+/g) || [];
        
        if (pathPoints.length >= 500) {
          // Start new path segment
          const lastPoint = pathPoints[pathPoints.length - 1];
          const coords = lastPoint.split(' ');
          const lastX = coords[0].slice(1);
          const lastY = coords[1];
          
          currentPath = createSVGElement('path', {
            stroke: currentTool === 'eraser' ? '#ffffff' : currentColor,
            'stroke-width': currentBrushSize,
            fill: 'none',
            'stroke-linecap': 'round',
            'stroke-linejoin': 'round',
            d: `M${lastX} ${lastY} L${pos.x} ${pos.y}`
          });
          drawingArea.appendChild(currentPath);
          paths.push(currentPath);

          // Send message for the completed path segment
          sendArtModifiedMessage(currentTool);
        } else {
          currentPath.setAttribute('d', currentD + `L${pos.x} ${pos.y}`);
        }
      }

      function setRedoButtonState() {
          if (redoStack.length === 0) {
            document.querySelector('.action-bg.redo').classList.add('inactive');
          } else {
            document.querySelector('.action-bg.redo').classList.remove('inactive');
          }
      }

      function stopDrawing() {
        if (currentTool === 'shape' && currentShapeElement && startPos) {
          finalizeShape(); // Message sent in finalizeShape
        } else if (isDrawing && currentPath && currentTool !== 'shape') {
          // Send message for completed brush/eraser/bucket paths
          sendArtModifiedMessage(currentTool);
        }
        
        isDrawing = false;
        currentPath = null;
        startPos = null;
        lastDrawPos = null;
        
        // Don't reset currentShapeElement for polyline - continue building
        if (currentTool !== 'shape' || currentShape !== 'polyline') {
          currentShapeElement = null;
        }
        
        if (paths.length === 0 || onlyPathIsClear()) {
          document.querySelector('.action-bg.undo').classList.add('inactive');
        } else {
          document.querySelector('.action-bg.undo').classList.remove('inactive');
        }
      }

      // **OPTIMIZATION: Streamlined mouse event handlers**
      canvas.addEventListener('mousedown', function(evt) {
        startDrawing(getMousePos(evt));
      });

      document.addEventListener('mousemove', function(evt) {
        if (isDrawing) {
          const currentPos = getMousePos(evt);
          
          // **OPTIMIZATION: Use unified brush radius check**
          if (isWithinBrushRadius(currentPos, lastDrawPos)) {
            return;
          } else {
            draw(currentPos);
            lastDrawPos = currentPos;
          }
          
          // Throttle with requestAnimationFrame for smooth performance
          // try without to reduce choppiness
          // if (mouseMoveThrottle) return;
          // mouseMoveThrottle = requestAnimationFrame(() => {
            // draw(currentPos);
            // lastDrawPos = currentPos;
            // mouseMoveThrottle = null;
          // });
        }
        
        // Polyline preview line
        if (currentTool === 'shape' && currentShape === 'polyline' && polylinePoints.length > 0) {
          if (!polylinePreview) {
            polylinePreview = createSVGElement('line', {
              stroke: currentColor,
              'stroke-width': currentBrushSize,
              'stroke-dasharray': [currentBrushSize*2, currentBrushSize]
            });
            drawingArea.appendChild(polylinePreview);
          }
          const lastX = polylinePoints[polylinePoints.length - 2];
          const lastY = polylinePoints[polylinePoints.length - 1];
          const pos = getMousePos(evt);
          
          const previewAttrs = { x1: lastX, y1: lastY, x2: pos.x, y2: pos.y };
          Object.entries(previewAttrs).forEach(([key, value]) => {
            polylinePreview.setAttribute(key, value);
          });
          
          if (!isWithinCanvas(pos)) {
            polylinePreview.remove();
            polylinePreview = null;
          }
        }
      });

      document.addEventListener('mouseup', stopDrawing);

      // **OPTIMIZATION: Simplified touch event handlers**
      canvas.addEventListener('touchstart', function(evt) {
        evt.preventDefault();
        startDrawing(getTouchPos(evt));
      }, { passive: false });

      canvas.addEventListener('touchmove', function(evt) {
        evt.preventDefault();
        const currentPos = getTouchPos(evt);
        
        // **OPTIMIZATION: Use unified brush radius check for touch**
        if (isWithinBrushRadius(currentPos, lastDrawPos)) {
          return;
        }
        
        draw(currentPos);
        lastDrawPos = currentPos;
      }, { passive: false });

      canvas.addEventListener('touchend', function(evt) {
        evt.preventDefault();
        stopDrawing();
      }, { passive: false });
      
      // **OPTIMIZATION: Unified polyline finalization for click events**
      document.addEventListener('click', function(evt) {
        if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {
          if (!isWithinCanvas(getMousePos(evt))) {
            resetPolylineState();
          }
        }
      });
      
      // **OPTIMIZATION: Unified polyline finalization for touch events**
      document.addEventListener('touchend', function(evt) {
        if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {
          const touch = evt.changedTouches[0];
          if (!isWithinCanvas(getTouchPos(evt))) {
            resetPolylineState();
          }
        }
      });

      // **OPTIMIZATION: Consolidated polyline finalization handlers**
      canvas.addEventListener('dblclick', function(evt) {
        evt.preventDefault();
        if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {
          resetPolylineState();
        }
      });

      // Parent window communication
      function sendMessageToParent(type, data = {}) {
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({ type, data }, '*');
        }
      }

      // Message listener for parent communication
      // was planned for use with saving/updating tokenArt, but we're just refreshing the image for now
      // window.addEventListener('message', function(event) {
      //   const { type, success, message } = event.data;
      //   // Handle messages from parent window if needed
      // });
      
      // Application initialization
      window.addEventListener('load', function() {
        updateCoordinateFactors();
        loadDrawing();

        if (paths.length > 0 && !onlyPathIsClear()) {
          document.querySelector('.action-bg.undo').classList.remove('inactive');
        }
        
        // Initialize brush slider position
        const initialBrushSize = currentBrushSize;
        const sliderX = 305 + ((initialBrushSize - 8) / 32) * 110;
        const initialHandleRadius = Math.max(4, Math.min(20, initialBrushSize * 0.5));
        
        // Batch initial slider setup
        brushSlider.setAttribute('cx', sliderX);
        brushSlider.setAttribute('r', initialHandleRadius);
      });
    ]]>
  </script>
</svg>
